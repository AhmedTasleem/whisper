{
    "summary": "The code has utility modules, compression ratio calculations, and timestamp formatting for ResultWriter class. It introduces WriteTSV and WriteJSON subclasses for TSV and JSON file formats, along with write_result and get_writer functions.",
    "details": [
        {
            "comment": "The code imports necessary modules, checks the system encoding, and provides several utility functions. It defines make_safe for converting strings to safe format, exact_div for integer division with assertion, str2bool for converting strings to boolean values, optional_int and optional_float for converting strings to respective numeric types if not \"None\".",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":0-41",
            "content": "import json\nimport os\nimport re\nimport sys\nimport zlib\nfrom typing import Callable, List, Optional, TextIO\nsystem_encoding = sys.getdefaultencoding()\nif system_encoding != \"utf-8\":\n    def make_safe(string):\n        # replaces any character not representable using the system default encoding with an '?',\n        # avoiding UnicodeEncodeError (https://github.com/openai/whisper/discussions/729).\n        return string.encode(system_encoding, errors=\"replace\").decode(system_encoding)\nelse:\n    def make_safe(string):\n        # utf-8 can encode any Unicode code point, so no need to do the round-trip encoding\n        return string\ndef exact_div(x, y):\n    assert x % y == 0\n    return x // y\ndef str2bool(string):\n    str2val = {\"True\": True, \"False\": False}\n    if string in str2val:\n        return str2val[string]\n    else:\n        raise ValueError(f\"Expected one of {set(str2val.keys())}, got {string}\")\ndef optional_int(string):\n    return None if string == \"None\" else int(string)\ndef optional_float(string):\n    return None if string == \"None\" else float(string)"
        },
        {
            "comment": "1. `compression_ratio` calculates the ratio of the size of compressed text to the original size in bytes.\n2. `format_timestamp` converts a non-negative timestamp into a formatted string, including hours if requested or if they are present.\n3. `get_start` retrieves the start time from the list of segment dictionaries, falling back to the first segment if necessary.\n4. `get_end` retrieves the end time from the last segment in reverse order of segments, or returns None if no segments are present.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":44-79",
            "content": "def compression_ratio(text) -> float:\n    text_bytes = text.encode(\"utf-8\")\n    return len(text_bytes) / len(zlib.compress(text_bytes))\ndef format_timestamp(\n    seconds: float, always_include_hours: bool = False, decimal_marker: str = \".\"\n):\n    assert seconds >= 0, \"non-negative timestamp expected\"\n    milliseconds = round(seconds * 1000.0)\n    hours = milliseconds // 3_600_000\n    milliseconds -= hours * 3_600_000\n    minutes = milliseconds // 60_000\n    milliseconds -= minutes * 60_000\n    seconds = milliseconds // 1_000\n    milliseconds -= seconds * 1_000\n    hours_marker = f\"{hours:02d}:\" if always_include_hours or hours > 0 else \"\"\n    return (\n        f\"{hours_marker}{minutes:02d}:{seconds:02d}{decimal_marker}{milliseconds:03d}\"\n    )\ndef get_start(segments: List[dict]) -> Optional[float]:\n    return next(\n        (w[\"start\"] for s in segments for w in s[\"words\"]),\n        segments[0][\"start\"] if segments else None,\n    )\ndef get_end(segments: List[dict]) -> Optional[float]:\n    return next(\n        (w[\"end\"] for s in reversed(segments) for w in reversed(s[\"words\"])),"
        },
        {
            "comment": "Class \"ResultWriter\" initializes with an output directory and takes a result dictionary, audio path, optional options dictionary, and additional keyword arguments. It writes the result to a file in the specified output directory with the file name based on the audio basename and the class's extension.\n\nThe \"WriteTXT\" class is a subclass of \"ResultWriter\" that writes the result as plain text to a file. For each segment in the result dictionary, it prints the text without leading or trailing whitespace.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":80-115",
            "content": "        segments[-1][\"end\"] if segments else None,\n    )\nclass ResultWriter:\n    extension: str\n    def __init__(self, output_dir: str):\n        self.output_dir = output_dir\n    def __call__(\n        self, result: dict, audio_path: str, options: Optional[dict] = None, **kwargs\n    ):\n        audio_basename = os.path.basename(audio_path)\n        audio_basename = os.path.splitext(audio_basename)[0]\n        output_path = os.path.join(\n            self.output_dir, audio_basename + \".\" + self.extension\n        )\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            self.write_result(result, file=f, options=options, **kwargs)\n    def write_result(\n        self, result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n    ):\n        raise NotImplementedError\nclass WriteTXT(ResultWriter):\n    extension: str = \"txt\"\n    def write_result(\n        self, result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n    ):\n        for segment in result[\"segments\"]:\n            print(segment[\"text\"].strip(), file=file, flush=True)"
        },
        {
            "comment": "This function is setting default values for options and defining an inner function to iterate through subtitles, keeping track of line length and count.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":118-144",
            "content": "class SubtitlesWriter(ResultWriter):\n    always_include_hours: bool\n    decimal_marker: str\n    def iterate_result(\n        self,\n        result: dict,\n        options: Optional[dict] = None,\n        *,\n        max_line_width: Optional[int] = None,\n        max_line_count: Optional[int] = None,\n        highlight_words: bool = False,\n        max_words_per_line: Optional[int] = None,\n    ):\n        options = options or {}\n        max_line_width = max_line_width or options.get(\"max_line_width\")\n        max_line_count = max_line_count or options.get(\"max_line_count\")\n        highlight_words = highlight_words or options.get(\"highlight_words\", False)\n        max_words_per_line = max_words_per_line or options.get(\"max_words_per_line\")\n        preserve_segments = max_line_count is None or max_line_width is None\n        max_line_width = max_line_width or 1000\n        max_words_per_line = max_words_per_line or 1000\n        def iterate_subtitles():\n            line_len = 0\n            line_count = 1\n            # the next subtitle to yield (a list of word timings with whitespace)"
        },
        {
            "comment": "This code is iterating through each segment of text, splitting it into smaller chunks based on maximum words per line, and handling breaks or pauses between segments if necessary.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":145-162",
            "content": "            subtitle: List[dict] = []\n            last: float = get_start(result[\"segments\"]) or 0.0\n            for segment in result[\"segments\"]:\n                chunk_index = 0\n                words_count = max_words_per_line\n                while chunk_index < len(segment[\"words\"]):\n                    remaining_words = len(segment[\"words\"]) - chunk_index\n                    if max_words_per_line > len(segment[\"words\"]) - chunk_index:\n                        words_count = remaining_words\n                    for i, original_timing in enumerate(\n                        segment[\"words\"][chunk_index : chunk_index + words_count]\n                    ):\n                        timing = original_timing.copy()\n                        long_pause = (\n                            not preserve_segments and timing[\"start\"] - last > 3.0\n                        )\n                        has_room = line_len + len(timing[\"word\"]) <= max_line_width\n                        seg_break = i == 0 and len(subtitle) > 0 and preserve_segments"
        },
        {
            "comment": "If line length > 0, has room, not a long pause, and not a segment break, increment line_len with word length. Otherwise, strip timing[\"word\"], check if subtitle is not empty, max line count not None, long pause or at max lines count, or segment break. If true, yield the subtitle and reset subtitle, line count to 1. Else, break the line",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":163-185",
            "content": "                        if (\n                            line_len > 0\n                            and has_room\n                            and not long_pause\n                            and not seg_break\n                        ):\n                            # line continuation\n                            line_len += len(timing[\"word\"])\n                        else:\n                            # new line\n                            timing[\"word\"] = timing[\"word\"].strip()\n                            if (\n                                len(subtitle) > 0\n                                and max_line_count is not None\n                                and (long_pause or line_count >= max_line_count)\n                                or seg_break\n                            ):\n                                # subtitle break\n                                yield subtitle\n                                subtitle = []\n                                line_count = 1\n                            elif line_len > 0:\n                                # line break"
        },
        {
            "comment": "Iterating through subtitles and yielding each one, formatting start and end timestamps.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":186-204",
            "content": "                                line_count += 1\n                                timing[\"word\"] = \"\\n\" + timing[\"word\"]\n                            line_len = len(timing[\"word\"].strip())\n                        subtitle.append(timing)\n                        last = timing[\"start\"]\n                    chunk_index += max_words_per_line\n            if len(subtitle) > 0:\n                yield subtitle\n        if len(result[\"segments\"]) > 0 and \"words\" in result[\"segments\"][0]:\n            for subtitle in iterate_subtitles():\n                subtitle_start = self.format_timestamp(subtitle[0][\"start\"])\n                subtitle_end = self.format_timestamp(subtitle[-1][\"end\"])\n                subtitle_text = \"\".join([word[\"word\"] for word in subtitle])\n                if highlight_words:\n                    last = subtitle_start\n                    all_words = [timing[\"word\"] for timing in subtitle]\n                    for i, this_word in enumerate(subtitle):\n                        start = self.format_timestamp(this_word[\"start\"])"
        },
        {
            "comment": "Iterates through subtitle data and formats start/end times for display. Applies underline formatting to specified words within the text. Yields segment start/end times with corresponding texts for display.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":205-227",
            "content": "                        end = self.format_timestamp(this_word[\"end\"])\n                        if last != start:\n                            yield last, start, subtitle_text\n                        yield start, end, \"\".join(\n                            [\n                                re.sub(r\"^(\\s*)(.*)$\", r\"\\1<u>\\2</u>\", word)\n                                if j == i\n                                else word\n                                for j, word in enumerate(all_words)\n                            ]\n                        )\n                        last = end\n                else:\n                    yield subtitle_start, subtitle_end, subtitle_text\n        else:\n            for segment in result[\"segments\"]:\n                segment_start = self.format_timestamp(segment[\"start\"])\n                segment_end = self.format_timestamp(segment[\"end\"])\n                segment_text = segment[\"text\"].strip().replace(\"-->\", \"->\")\n                yield segment_start, segment_end, segment_text\n    def format_timestamp(self, seconds: float):"
        },
        {
            "comment": "utils.py:228-259 defines two classes WriteVTT and WriteSRT, which inherit from the SubtitlesWriter class. Both classes have a write_result method that writes subtitle information in either VTT or SRT format to the specified file. The write_result method iterates over the result dictionary using the iterate_result method and prints formatted start, end, and text lines for each subtitle. WriteVTT has always_include_hours=False and decimal_marker=\".\" while WriteSRT has always_include_hours=True and decimal_marker=\",\"",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":228-259",
            "content": "        return format_timestamp(\n            seconds=seconds,\n            always_include_hours=self.always_include_hours,\n            decimal_marker=self.decimal_marker,\n        )\nclass WriteVTT(SubtitlesWriter):\n    extension: str = \"vtt\"\n    always_include_hours: bool = False\n    decimal_marker: str = \".\"\n    def write_result(\n        self, result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n    ):\n        print(\"WEBVTT\\n\", file=file)\n        for start, end, text in self.iterate_result(result, options, **kwargs):\n            print(f\"{start} --> {end}\\n{text}\\n\", file=file, flush=True)\nclass WriteSRT(SubtitlesWriter):\n    extension: str = \"srt\"\n    always_include_hours: bool = True\n    decimal_marker: str = \",\"\n    def write_result(\n        self, result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n    ):\n        for i, (start, end, text) in enumerate(\n            self.iterate_result(result, options, **kwargs), start=1\n        ):\n            print(f\"{i}\\n{start} --> {end}\\n{text}\\n\", file=file, flush=True)"
        },
        {
            "comment": "This code defines two classes, `WriteTSV` and `WriteJSON`, both of which inherit from the `ResultWriter` class. The `WriteTSV` class is responsible for writing transcripts to a file in TSV format. It takes a dictionary `result` as input along with an optional `options` dictionary. It prints each segment's start time, end time, and text to the file separated by tabs.\n\nThe `WriteJSON` class, on the other hand, writes the result as JSON format. Both classes implement the `write_result()` method which takes in a `result` dictionary, a `file` object to write to, an optional `options` dictionary, and any additional keyword arguments.\n\nIn summary: Code defines two ResultWriter subclasses (WriteTSV, WriteJSON) for writing transcripts to files in TSV and JSON format respectively.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":262-284",
            "content": "class WriteTSV(ResultWriter):\n    \"\"\"\n    Write a transcript to a file in TSV (tab-separated values) format containing lines like:\n    <start time in integer milliseconds>\\t<end time in integer milliseconds>\\t<transcript text>\n    Using integer milliseconds as start and end times means there's no chance of interference from\n    an environment setting a language encoding that causes the decimal in a floating point number\n    to appear as a comma; also is faster and more efficient to parse & store, e.g., in C++.\n    \"\"\"\n    extension: str = \"tsv\"\n    def write_result(\n        self, result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n    ):\n        print(\"start\", \"end\", \"text\", sep=\"\\t\", file=file)\n        for segment in result[\"segments\"]:\n            print(round(1000 * segment[\"start\"]), file=file, end=\"\\t\")\n            print(round(1000 * segment[\"end\"]), file=file, end=\"\\t\")\n            print(segment[\"text\"].strip().replace(\"\\t\", \" \"), file=file, flush=True)\nclass WriteJSON(ResultWriter):"
        },
        {
            "comment": "The code defines a function `write_result` that writes a dictionary to a file in JSON format. It also provides a `get_writer` function that returns a writer function based on the output format specified (either a specific format or \"all\" for all available formats). If \"all\" is specified, it creates a writer function that can write files in all supported formats.",
            "location": "\"/media/root/Toshiba XG3/works/whisper/docs/src/whisper/utils.py\":285-315",
            "content": "    extension: str = \"json\"\n    def write_result(\n        self, result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n    ):\n        json.dump(result, file)\ndef get_writer(\n    output_format: str, output_dir: str\n) -> Callable[[dict, TextIO, dict], None]:\n    writers = {\n        \"txt\": WriteTXT,\n        \"vtt\": WriteVTT,\n        \"srt\": WriteSRT,\n        \"tsv\": WriteTSV,\n        \"json\": WriteJSON,\n    }\n    if output_format == \"all\":\n        all_writers = [writer(output_dir) for writer in writers.values()]\n        def write_all(\n            result: dict, file: TextIO, options: Optional[dict] = None, **kwargs\n        ):\n            for writer in all_writers:\n                writer(result, file, options, **kwargs)\n        return write_all\n    return writers[output_format](output_dir)"
        }
    ]
}